package main

import (
	"net"
	"testing"
	"time"
)

//
// Implement a mock version of net.Conn for testing
//

type MockConn struct {
	readBytes    [][]byte
	writtenBytes []byte

	readError        *error
	closeAfterWrites int
	numWrites        int
	writtenBytePtr   int
}

func (conn MockConn) Read(b []byte) (n int, err error) {
	read := copy(b, conn.readBytes[conn.numWrites])
	conn.numWrites++
	return read, nil
}

func (conn MockConn) Write(b []byte) (n int, err error) {
	written := copy(conn.writtenBytes[conn.writtenBytePtr:], b)
	conn.writtenBytePtr += written
	return written, nil
}

func (conn MockConn) Close() error {
	return nil
}

func (conn MockConn) LocalAddr() net.Addr {
	return &net.IPAddr{net.IPv4(192, 168, 1, 1), ""}
}

func (conn MockConn) RemoteAddr() net.Addr {
	return &net.IPAddr{net.IPv4(192, 168, 1, 1), ""}
}

func (conn MockConn) SetDeadline(t time.Time) error {
	return nil
}

func (conn MockConn) SetReadDeadline(t time.Time) error {
	return nil
}

func (conn MockConn) SetWriteDeadline(t time.Time) error {
	return nil
}

func NewMockConn() *MockConn {
	return &MockConn{readBytes: make([][]byte, 1024, 1024), writtenBytes: make([]byte, 1024, 1024)}
}

func TestKeyGen(t *testing.T) {
	gen := KeyGen()

	i := gen()
	j := gen()
	k := gen()

	if i != 1 || j != 2 || k != 3 {
		t.Errorf("Incorrect sequence generated by KeyGen")
	}

}

func TestNewWorld(t *testing.T) {
	w := NewWorld()

	if w.players.Len() != 0 {
		t.Errorf("Expected world to exist and have 0 players.")
	}
}

func TestNewRoom(t *testing.T) {
	world := NewWorld()
	hall, err := world.NewRoom("The Hall")

	if hall.Name() != "The Hall" {
		t.Errorf("Expected name to be 'The Hall'")
	}
	if hall == nil || err != nil {
		t.Errorf("Expected to create a new room.")
	}
	if world.rooms.Len() != 1 || !world.rooms.Contains(hall) {
		t.Errorf("Expected room to have been added to the world.")
	}
}

func TestNewPlayer(t *testing.T) {
	world := NewWorld()
	hall, _ := world.NewRoom("The Hall")
	bob, _ := world.NewPlayer("bob", hall)
	if bob.Name() != "bob" {
		t.Errorf("Expected player name to be bob, but was %s", bob.name)
	}
	if bob.location != hall {
		t.Errorf("Expected player's location to be the hall")
	}
	if world.players.Len() != 1 || !world.players.Contains(bob) {
		t.Errorf("Expected player to have been added to world.")
	}
}

func TestNewPlayerCantReuseNames(t *testing.T) {
	world := NewWorld()
	hall, _ := world.NewRoom("The Hall")
	world.NewPlayer("bob", hall)
	otherBob, err := world.NewPlayer("bob", hall)
	if otherBob != nil || err == nil {
		t.Errorf("Should not have been able to create duplicate user")
	}
}

func TestTell(t *testing.T) {
	conn := NewMockConn()
	client := NewClient(conn) // &Client{conn: conn}
	client.tell("Hello, world!")

	actual := string(conn.writtenBytes[0:16])
	if actual != "Hello, world!\r\n\u0000" {
		t.Errorf("`tell` did not write bytes correctly: '%s'", actual)
	}
}

func TestNewExit(t *testing.T) {
	world := NewWorld()
	hall, _ := world.NewRoom("The Hall")
	den, _ := world.NewRoom("The Den")

	east, err1 := world.NewExit(hall, "east", den)
	west, err2 := world.NewExit(den, "west", hall)

	if east.Name() != "east" {
		t.Errorf("Expected hall exit to be named 'east'")
	}
	if west.Name() != "west" {
		t.Errorf("Expected hall exit to be named 'east'")
	}
	if err1 != nil || err2 != nil {
		t.Errorf("Error while creating exits.")
	}
}

func TestNewExitAddsToWorldSet(t *testing.T) {
	world := NewWorld()
	hall, _ := world.NewRoom("The Hall")
	den, _ := world.NewRoom("The Den")

	world.NewExit(hall, "east", den)
	world.NewExit(den, "west", hall)

	if world.exits.Len() != 2 {
		t.Errorf("Exits were not added to the global set:")
	}
}

func TestNewExitFailsWhenCreatingDuplicateExits(t *testing.T) {
	world := NewWorld()
	hall, _ := world.NewRoom("The Hall")
	den, _ := world.NewRoom("The Den")

	world.NewExit(hall, "east", den)
	exit, err := world.NewExit(hall, "east", hall)

	if exit != nil || err == nil {
		t.Errorf("Creating exit should have failed.")
	}
}

// We cannot use '==' to compare Commands, so we must implement our
// own equality function.
func equalCommands(a Command, b Command) bool {
	if a.verb != b.verb {
		return false
	}

	if a.args.argString != b.args.argString {
		return false
	}

	if len(a.args.argSlice) != len(b.args.argSlice) {
		return false
	}

	for i, arg := range a.args.argSlice {
		if arg != b.args.argSlice[i] {
			return false
		}
	}

	return true
}

var commandInputs = []string{
	"",
	"look",
	"walk east",
	"west", // There's an exit to the west
	"east", // No such exit
	"say foo bar baz",
}

var expectedCommands = []Command{
	{"", CommandArgs{"", []string{}}},
	{"look", CommandArgs{"", []string{}}},
	{"walk", CommandArgs{"east", []string{"east"}}},
	{"move", CommandArgs{"west", []string{"west"}}},
	{"east", CommandArgs{"", []string{}}},
	{"say", CommandArgs{"foo bar baz", []string{"foo", "bar", "baz"}}},
}

func TestParseCommand(t *testing.T) {
	conn := NewMockConn()
	client := NewClient(conn)

	world := NewWorld()

	bedroom, _ := world.NewRoom("The Bedroom")
	hall, _ := world.NewRoom("The Hall")

	world.NewExit(bedroom, "west", hall)

	player, _ := world.NewPlayer("bob", bedroom)
	client.player = player

	for i, cmd := range commandInputs {
		command := world.parseCommand(client, cmd)

		if !equalCommands(command, expectedCommands[i]) {
			t.Errorf("%d: Expected args to be equal. Actual: %s", i, command)
		}
	}
}

func TestPlayersCanBeAwakeOrAsleep(t *testing.T) {
	world := NewWorld()
	hall, _ := world.NewRoom("The Hall")
	bob, _ := world.NewPlayer("bob", hall)
	jim, _ := world.NewPlayer("jim", hall)

	if bob.Awake() || jim.Awake() {
		t.Errorf("Neither bob nor jim should be awake")
	}

	bob.awake = true

	if !bob.Awake() || jim.Awake() {
		t.Errorf("Bob should be awake, jim should not.")
	}

	jim.awake = true

	if !bob.Awake() || !jim.Awake() {
		t.Errorf("Bob and jim should be be awake.")
	}
}

func TestConnectingShouldWakeUpPlayers(t *testing.T) {
	conn := NewMockConn()
	client := NewClient(conn) // &Client{conn: conn}
	world := NewWorld()
	hall, _ := world.NewRoom("The Hall")
	bob, _ := world.NewPlayer("bob", hall)

	if bob.Awake() {
		t.Errorf("Bob should not be awake.")
	}

	doConnect(world, client, CommandArgs{"bob", []string{"bob"}})

	if client.player != bob {
		t.Errorf("Connecting should have linked the client and the player")
	}

	if !bob.Awake() {
		t.Errorf("Connecting should have woken up bob.")
	}
}
